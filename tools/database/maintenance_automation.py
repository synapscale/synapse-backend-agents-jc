#!/usr/bin/env python3
"""
ü§ñ MAINTENANCE AUTOMATION - Sistema de Manuten√ß√£o Automatizada

Sistema integrado que resolve EXATAMENTE os pontos mencionados:
- Configura√ß√£o frequente e manuten√ß√£o automatizada
- Sincroniza√ß√£o perfeita (banco, API, models, schemas, auth)
- OpenAPI.json sempre atualizado
- Fluxo otimizado com menor dor de cabe√ßa
- Relat√≥rios completos e acion√°veis

Este √© o N√öCLEO da automa√ß√£o - executa tudo em sequ√™ncia inteligente!
"""

import os
import sys
import json
import subprocess
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional
from dotenv import load_dotenv

# Cores para terminal
class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    END = '\033[0m'

load_dotenv()

class MaintenanceAutomation:
    def __init__(self):
        self.project_root = Path(__file__).parent.parent.parent
        self.tools_dir = self.project_root / "tools" / "database"
        self.reports_dir = self.project_root / "reports" / "maintenance"
        self.reports_dir.mkdir(parents=True, exist_ok=True)
        
        self.session_id = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.results = {}
        self.issues = []
        self.suggestions = []
        
    def log(self, message: str, level: str = "INFO", color: str = Colors.WHITE):
        """Log com timestamp e cores"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"{color}[{timestamp}] {level}: {message}{Colors.END}")

    def run_tool(self, tool_name: str, description: str, *args) -> Dict[str, Any]:
        """Executa uma ferramenta e captura resultado"""
        self.log(f"üîÑ {description}", "RUN", Colors.CYAN)
        
        script_path = self.tools_dir / f"{tool_name}.py"
        
        if not script_path.exists():
            self.log(f"‚ùå Script n√£o encontrado: {script_path}", "ERROR", Colors.RED)
            return {"success": False, "error": "Script n√£o encontrado"}
        
        try:
            cmd = [sys.executable, str(script_path)] + list(args)
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                cwd=self.project_root,
                timeout=120
            )
            
            success = result.returncode == 0
            
            if success:
                self.log(f"‚úÖ {description} - Conclu√≠do", "SUCCESS", Colors.GREEN)
            else:
                self.log(f"‚ùå {description} - Falhou", "ERROR", Colors.RED)
            
            return {
                "success": success,
                "returncode": result.returncode,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "execution_time": time.time()
            }
            
        except subprocess.TimeoutExpired:
            self.log(f"‚è∞ {description} - Timeout", "ERROR", Colors.RED)
            return {"success": False, "error": "Timeout"}
        except Exception as e:
            self.log(f"üí• {description} - Erro: {e}", "ERROR", Colors.RED)
            return {"success": False, "error": str(e)}

    def phase_1_health_check(self) -> bool:
        """Fase 1: Verifica√ß√£o completa de sa√∫de"""
        self.log("üè• FASE 1: Verifica√ß√£o de Sa√∫de do Sistema", "PHASE", Colors.BOLD)
        
        # Executar health check master
        health_result = self.run_tool(
            "health_check_master",
            "Health Check Completo",
            "--json",
            "--report", str(self.reports_dir / f"health_report_{self.session_id}.json")
        )
        
        self.results["health_check"] = health_result
        
        if health_result["success"]:
            # Analisar resultado do health check
            try:
                if health_result["stdout"]:
                    health_data = json.loads(health_result["stdout"])
                    health_score = health_data.get("health_score", 0)
                    
                    if health_score >= 90:
                        self.log(f"üéâ Sistema saud√°vel! Score: {health_score:.1f}%", "SUCCESS", Colors.GREEN)
                        return True
                    elif health_score >= 70:
                        self.log(f"‚ö†Ô∏è Sistema com avisos. Score: {health_score:.1f}%", "WARNING", Colors.YELLOW)
                        self.issues.extend(health_data.get("warnings", []))
                        return True
                    else:
                        self.log(f"üö® Sistema cr√≠tico! Score: {health_score:.1f}%", "CRITICAL", Colors.RED)
                        self.issues.extend(health_data.get("errors", []))
                        return False
                        
            except json.JSONDecodeError:
                self.log("‚ö†Ô∏è N√£o foi poss√≠vel analisar resultado do health check", "WARNING", Colors.YELLOW)
        
        return health_result["success"]

    def phase_2_sync_validation(self) -> bool:
        """Fase 2: Valida√ß√£o de sincroniza√ß√£o"""
        self.log("üîÑ FASE 2: Valida√ß√£o de Sincroniza√ß√£o", "PHASE", Colors.BOLD)
        
        # Executar sync validator
        sync_result = self.run_tool(
            "sync_validator",
            "Valida√ß√£o de Sincroniza√ß√£o",
            "--json",
            "--report", str(self.reports_dir / f"sync_report_{self.session_id}.json")
        )
        
        self.results["sync_validation"] = sync_result
        
        if sync_result["success"]:
            try:
                if sync_result["stdout"]:
                    sync_data = json.loads(sync_result["stdout"])
                    
                    critical_issues = sync_data.get("summary", {}).get("critical_issues", 0)
                    warnings = sync_data.get("summary", {}).get("warnings", 0)
                    
                    if critical_issues == 0 and warnings == 0:
                        self.log("üéâ Tudo sincronizado perfeitamente!", "SUCCESS", Colors.GREEN)
                    elif critical_issues == 0:
                        self.log(f"‚ö†Ô∏è Sincronizado com {warnings} avisos", "WARNING", Colors.YELLOW)
                        # Adicionar sugest√µes de sincroniza√ß√£o
                        for issue in sync_data.get("db_model_inconsistencies", []):
                            if issue.get("severity") == "warning":
                                self.suggestions.append(issue.get("suggestion", ""))
                    else:
                        self.log(f"üö® {critical_issues} problemas cr√≠ticos de sincroniza√ß√£o!", "CRITICAL", Colors.RED)
                        for issue in sync_data.get("db_model_inconsistencies", []):
                            if issue.get("severity") == "error":
                                self.issues.append(issue.get("message", ""))
                                self.suggestions.append(issue.get("suggestion", ""))
                        return False
                        
            except json.JSONDecodeError:
                self.log("‚ö†Ô∏è N√£o foi poss√≠vel analisar resultado da sincroniza√ß√£o", "WARNING", Colors.YELLOW)
        
        return sync_result.get("returncode", 1) != 1  # 1 = critical issues

    def phase_3_documentation_update(self) -> bool:
        """Fase 3: Atualiza√ß√£o autom√°tica da documenta√ß√£o"""
        self.log("üìö FASE 3: Atualiza√ß√£o da Documenta√ß√£o", "PHASE", Colors.BOLD)
        
        # Executar gerador de documenta√ß√£o
        doc_result = self.run_tool(
            "doc_generator",
            "Gera√ß√£o de Documenta√ß√£o",
            "--output-dir", str(self.reports_dir / f"docs_{self.session_id}")
        )
        
        self.results["documentation"] = doc_result
        
        if doc_result["success"]:
            self.log("üìñ Documenta√ß√£o atualizada com sucesso!", "SUCCESS", Colors.GREEN)
            
            # Copiar documenta√ß√£o para pasta principal se tudo estiver OK
            docs_source = self.reports_dir / f"docs_{self.session_id}"
            docs_target = self.project_root / "docs" / "database"
            
            if docs_source.exists():
                try:
                    import shutil
                    if docs_target.exists():
                        shutil.rmtree(docs_target)
                    shutil.copytree(docs_source, docs_target)
                    self.log(f"üìÅ Documenta√ß√£o copiada para {docs_target}", "SUCCESS", Colors.GREEN)
                except Exception as e:
                    self.log(f"‚ö†Ô∏è Erro ao copiar documenta√ß√£o: {e}", "WARNING", Colors.YELLOW)
        
        return doc_result["success"]

    def phase_4_openapi_sync(self) -> bool:
        """Fase 4: Sincroniza√ß√£o do OpenAPI"""
        self.log("üìã FASE 4: Sincroniza√ß√£o do OpenAPI", "PHASE", Colors.BOLD)
        
        # Verificar se h√° arquivo OpenAPI para atualizar
        possible_openapi_paths = [
            self.project_root / "docs" / "openapi.json",
            self.project_root / "src" / "openapi.json",
            self.project_root / "openapi.json",
            self.project_root / "static" / "openapi.json"
        ]
        
        openapi_file = None
        for path in possible_openapi_paths:
            if path.exists():
                openapi_file = path
                break
        
        if not openapi_file:
            self.log("‚ö†Ô∏è Arquivo OpenAPI n√£o encontrado - criando sugest√£o", "WARNING", Colors.YELLOW)
            self.suggestions.append("Considere gerar arquivo openapi.json automaticamente")
            return True
        
        # Verificar se OpenAPI est√° atualizado
        try:
            file_age = time.time() - openapi_file.stat().st_mtime
            
            if file_age > 86400:  # Mais de 1 dia
                self.log("‚ö†Ô∏è OpenAPI pode estar desatualizado (>1 dia)", "WARNING", Colors.YELLOW)
                self.suggestions.append(f"Atualizar {openapi_file} - arquivo antigo")
            else:
                self.log("‚úÖ OpenAPI parece atualizado", "SUCCESS", Colors.GREEN)
            
            return True
            
        except Exception as e:
            self.log(f"‚ùå Erro ao verificar OpenAPI: {e}", "ERROR", Colors.RED)
            return False

    def phase_5_generate_action_plan(self) -> Dict[str, Any]:
        """Fase 5: Gerar plano de a√ß√£o"""
        self.log("üìã FASE 5: Gerando Plano de A√ß√£o", "PHASE", Colors.BOLD)
        
        # Categorizar issues por prioridade
        critical_issues = [issue for issue in self.issues if "cr√≠tico" in issue.lower() or "error" in issue.lower()]
        warning_issues = [issue for issue in self.issues if issue not in critical_issues]
        
        action_plan = {
            "session_id": self.session_id,
            "timestamp": datetime.now().isoformat(),
            "summary": {
                "total_phases": 5,
                "successful_phases": sum(1 for r in self.results.values() if r.get("success", False)),
                "critical_issues": len(critical_issues),
                "warnings": len(warning_issues),
                "suggestions": len(self.suggestions)
            },
            "phase_results": self.results,
            "critical_issues": critical_issues,
            "warnings": warning_issues,
            "suggestions": self.suggestions,
            "next_actions": []
        }
        
        # Gerar a√ß√µes recomendadas
        if critical_issues:
            action_plan["next_actions"].append({
                "priority": "CR√çTICA",
                "action": "Resolver problemas cr√≠ticos identificados",
                "details": critical_issues
            })
        
        if warning_issues:
            action_plan["next_actions"].append({
                "priority": "M√âDIA",
                "action": "Revisar e resolver avisos",
                "details": warning_issues
            })
        
        if self.suggestions:
            action_plan["next_actions"].append({
                "priority": "BAIXA",
                "action": "Implementar melhorias sugeridas",
                "details": self.suggestions
            })
        
        # Agendar pr√≥xima execu√ß√£o
        action_plan["next_actions"].append({
            "priority": "ROTINA",
            "action": "Executar pr√≥xima verifica√ß√£o automatizada",
            "details": ["Agendar para 24h ou ap√≥s mudan√ßas significativas"]
        })
        
        return action_plan

    def generate_maintenance_report(self, action_plan: Dict[str, Any]) -> str:
        """Gera relat√≥rio de manuten√ß√£o em formato leg√≠vel"""
        
        report = []
        report.append("# ü§ñ Relat√≥rio de Manuten√ß√£o Automatizada")
        report.append("")
        report.append(f"**Sess√£o:** {self.session_id}")
        report.append(f"**Data/Hora:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append("")
        
        # Status geral
        success_rate = (action_plan["summary"]["successful_phases"] / action_plan["summary"]["total_phases"]) * 100
        
        if success_rate == 100 and action_plan["summary"]["critical_issues"] == 0:
            status = "üü¢ EXCELENTE"
            status_desc = "Sistema funcionando perfeitamente"
        elif success_rate >= 80 and action_plan["summary"]["critical_issues"] == 0:
            status = "üü° BOM"
            status_desc = "Sistema est√°vel com pequenos ajustes necess√°rios"
        else:
            status = "üî¥ ATEN√á√ÉO NECESS√ÅRIA"
            status_desc = "Sistema requer interven√ß√£o imediata"
        
        report.append(f"## {status}")
        report.append(f"*{status_desc}*")
        report.append("")
        
        # Resumo executivo
        report.append("## üìä Resumo Executivo")
        report.append("")
        report.append(f"- ‚úÖ **Fases conclu√≠das:** {action_plan['summary']['successful_phases']}/{action_plan['summary']['total_phases']}")
        report.append(f"- üö® **Problemas cr√≠ticos:** {action_plan['summary']['critical_issues']}")
        report.append(f"- ‚ö†Ô∏è **Avisos:** {action_plan['summary']['warnings']}")
        report.append(f"- üí° **Sugest√µes de melhoria:** {action_plan['summary']['suggestions']}")
        report.append("")
        
        # Resultados por fase
        report.append("## üîÑ Resultados por Fase")
        report.append("")
        
        phase_names = {
            "health_check": "üè• Health Check Completo",
            "sync_validation": "üîÑ Valida√ß√£o de Sincroniza√ß√£o", 
            "documentation": "üìö Atualiza√ß√£o da Documenta√ß√£o",
            "openapi_sync": "üìã Sincroniza√ß√£o do OpenAPI"
        }
        
        for phase_key, result in action_plan["phase_results"].items():
            phase_name = phase_names.get(phase_key, phase_key)
            status_icon = "‚úÖ" if result.get("success") else "‚ùå"
            report.append(f"### {status_icon} {phase_name}")
            
            if result.get("success"):
                report.append("Status: **Conclu√≠do com sucesso**")
            else:
                report.append("Status: **Falhou**")
                if result.get("error"):
                    report.append(f"Erro: `{result['error']}`")
            
            report.append("")
        
        # Plano de a√ß√£o
        if action_plan["next_actions"]:
            report.append("## üìã Plano de A√ß√£o")
            report.append("")
            
            for action in action_plan["next_actions"]:
                priority_colors = {
                    "CR√çTICA": "üî¥",
                    "M√âDIA": "üü°", 
                    "BAIXA": "üü¢",
                    "ROTINA": "üîµ"
                }
                
                priority_icon = priority_colors.get(action["priority"], "‚ö™")
                
                report.append(f"### {priority_icon} {action['priority']}: {action['action']}")
                
                if action.get("details"):
                    for detail in action["details"]:
                        report.append(f"- {detail}")
                
                report.append("")
        
        # Pr√≥ximos passos
        report.append("## üöÄ Pr√≥ximos Passos Recomendados")
        report.append("")
        
        if action_plan["summary"]["critical_issues"] > 0:
            report.append("1. **URGENTE:** Resolver problemas cr√≠ticos listados acima")
            report.append("2. Executar novamente ap√≥s corre√ß√µes")
        else:
            report.append("1. Revisar avisos e implementar sugest√µes")
            report.append("2. Agendar pr√≥xima verifica√ß√£o autom√°tica")
        
        report.append("3. Monitorar health dashboard regularmente")
        report.append("4. Manter documenta√ß√£o atualizada")
        report.append("")
        
        # Comandos √∫teis
        report.append("## üõ†Ô∏è Comandos √öteis")
        report.append("")
        report.append("```bash")
        report.append("# Executar manuten√ß√£o completa")
        report.append("python tools/database/maintenance_automation.py")
        report.append("")
        report.append("# Apenas verifica√ß√£o de sa√∫de")
        report.append("python tools/database/health_check_master.py")
        report.append("")
        report.append("# Valida√ß√£o de sincroniza√ß√£o")
        report.append("python tools/database/sync_validator.py")
        report.append("")
        report.append("# Atualizar documenta√ß√£o")
        report.append("python tools/database/doc_generator.py")
        report.append("```")
        report.append("")
        
        report.append("---")
        report.append("*Relat√≥rio gerado automaticamente pelo Sistema de Manuten√ß√£o*")
        
        return "\n".join(report)

    def run_full_maintenance(self) -> Dict[str, Any]:
        """Executa manuten√ß√£o completa automatizada"""
        self.log("üöÄ INICIANDO MANUTEN√á√ÉO AUTOMATIZADA COMPLETA", "START", Colors.BOLD)
        self.log(f"üìÅ Sess√£o: {self.session_id}", "INFO", Colors.WHITE)
        
        start_time = time.time()
        
        # Fase 1: Health Check
        phase1_success = self.phase_1_health_check()
        
        # Fase 2: Sync Validation
        phase2_success = self.phase_2_sync_validation()
        
        # Se fases cr√≠ticas falharam, parar aqui
        if not phase1_success or not phase2_success:
            self.log("üõë Parando execu√ß√£o - problemas cr√≠ticos detectados", "CRITICAL", Colors.RED)
        else:
            # Fase 3: Documentation
            self.phase_3_documentation_update()
            
            # Fase 4: OpenAPI
            self.phase_4_openapi_sync()
        
        # Fase 5: Action Plan (sempre executar)
        action_plan = self.phase_5_generate_action_plan()
        
        # Gerar relat√≥rio final
        report_content = self.generate_maintenance_report(action_plan)
        report_file = self.reports_dir / f"maintenance_report_{self.session_id}.md"
        
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(report_content)
        
        # Salvar action plan em JSON
        action_plan_file = self.reports_dir / f"action_plan_{self.session_id}.json"
        with open(action_plan_file, 'w', encoding='utf-8') as f:
            json.dump(action_plan, f, indent=2, ensure_ascii=False)
        
        execution_time = time.time() - start_time
        
        # Exibir resumo final
        print(f"\n{Colors.BOLD}{'='*80}{Colors.END}")
        print(f"{Colors.BOLD}üèÅ MANUTEN√á√ÉO AUTOMATIZADA CONCLU√çDA{Colors.END}")
        print(f"{Colors.BOLD}{'='*80}{Colors.END}")
        
        print(f"\n‚è±Ô∏è  **Tempo de execu√ß√£o:** {execution_time:.2f} segundos")
        print(f"üìÅ **Relat√≥rios salvos em:** {self.reports_dir}")
        print(f"üìã **Relat√≥rio principal:** {report_file.name}")
        print(f"üìä **Action plan:** {action_plan_file.name}")
        
        if action_plan["summary"]["critical_issues"] == 0:
            print(f"\n{Colors.GREEN}üéâ Sistema est√° funcionando corretamente!{Colors.END}")
        else:
            print(f"\n{Colors.RED}‚ö†Ô∏è {action_plan['summary']['critical_issues']} problemas cr√≠ticos detectados{Colors.END}")
            print(f"{Colors.YELLOW}üìã Consulte o action plan para pr√≥ximos passos{Colors.END}")
        
        print(f"\n{Colors.CYAN}üí° Dica: Agende este script para executar automaticamente!{Colors.END}")
        print(f"{Colors.BOLD}{'='*80}{Colors.END}")
        
        return action_plan

def main():
    import argparse
    
    parser = argparse.ArgumentParser(description="Maintenance Automation - Manuten√ß√£o automatizada completa")
    parser.add_argument("--dry-run", action="store_true", help="Simular execu√ß√£o sem fazer mudan√ßas")
    parser.add_argument("--phase", type=str, choices=["health", "sync", "docs", "openapi"], help="Executar apenas uma fase espec√≠fica")
    parser.add_argument("--output-dir", type=str, help="Diret√≥rio customizado para relat√≥rios")
    
    args = parser.parse_args()
    
    automation = MaintenanceAutomation()
    
    if args.output_dir:
        automation.reports_dir = Path(args.output_dir)
        automation.reports_dir.mkdir(parents=True, exist_ok=True)
    
    if args.dry_run:
        print("üß™ Modo DRY RUN - apenas simula√ß√£o")
        # Implementar simula√ß√£o se necess√°rio
        return
    
    if args.phase:
        # Executar apenas uma fase espec√≠fica
        if args.phase == "health":
            automation.phase_1_health_check()
        elif args.phase == "sync":
            automation.phase_2_sync_validation()
        elif args.phase == "docs":
            automation.phase_3_documentation_update()
        elif args.phase == "openapi":
            automation.phase_4_openapi_sync()
    else:
        # Executar manuten√ß√£o completa
        action_plan = automation.run_full_maintenance()
        
        # Exit code baseado no resultado
        if action_plan["summary"]["critical_issues"] > 0:
            sys.exit(1)  # Problemas cr√≠ticos
        elif action_plan["summary"]["warnings"] > 0:
            sys.exit(2)  # Avisos
        else:
            sys.exit(0)  # Tudo OK

if __name__ == "__main__":
    main()
